import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
from mpl_toolkits.mplot3d import Axes3D
from IPython.display import HTML

# Configure matplotlib for Colab
%matplotlib inline
plt.rcParams['animation.html'] = 'jshtml'

# --- Model and Loss Parameters ---
shock_std = [0.01, 0.01]
shock_persistence = [0.9, 0.5]
lambda_pi, lambda_x, lambda_i = 1.0, 1.0, 0.1
n_sim = 500

# --- System Template Matrices ---
A_template = np.array([
    [0.5, -0.5, -0.5, 0.0],     
    [0.05, 0.98, -0.05, 0.0],   
    [0.2, 1.2, 0.0, 0.8],       
    [0.0, 0.0, 1.0, 0.0]        
])

B = np.zeros((4, 2))
B[:, 0] = [1.0, 0.0, 0.0, 0.0]  # technology
B[:, 1] = [0.0, 0.0, 1.0, 0.0]  # monetary

# --- Evaluation Function ---
def evaluate_policy(phi_pi, phi_y, A_template, B, T, n_sim,
                    lambda_pi=1.0, lambda_x=1.0, lambda_i=0.1):
    A = A_template.copy()
    A[2, 0], A[2, 1] = phi_y, phi_pi
    
    paths = np.zeros((n_sim, 4, T))
    
    for s in range(n_sim):
        y = np.zeros((4, T))
        shocks = np.zeros((2, T))
        
        # Generate shocks for both series
        for j in range(2):
            shocks[j, 0] = shock_std[j] * np.random.randn()
            for t in range(1, T):
                shocks[j, t] = shock_persistence[j] * shocks[j, t-1] + shock_std[j] * np.random.randn()
        
        # Simulate the system
        for t in range(1, T):
            y[:, t] = A @ y[:, t-1] + B @ shocks[:, t]
        
        paths[s] = y
    
    # Extract paths for each variable
    x_paths = paths[:, 0, :]
    pi_paths = paths[:, 1, :]
    i_paths = paths[:, 2, :]
    
    # Calculate volatilities
    vol_x = np.mean(np.std(x_paths, axis=1))
    vol_pi = np.mean(np.std(pi_paths, axis=1))
    vol_i = np.mean(np.std(i_paths, axis=1))
    
    # Calculate loss
    loss = lambda_pi * vol_pi**2 + lambda_x * vol_x**2 + lambda_i * vol_i**2
    return loss

# --- Grids for Parameters ---
phi_pi_vals = np.linspace(0.5, 2.5, 15)
phi_y_vals = np.linspace(0.0, 1.5, 15)
X, Y = np.meshgrid(phi_pi_vals, phi_y_vals)

# --- Restricted Time Horizons ---
time_horizons = [10, 20, 30, 40]
Zs = []

# --- Compute Loss Surfaces for Selected T ---
for T in time_horizons:
    print(f"Simulating T={T}")
    Z = np.zeros_like(X)
    for i in range(len(phi_y_vals)):
        for j in range(len(phi_pi_vals)):
            loss = evaluate_policy(phi_pi_vals[j], phi_y_vals[i], A_template, B, T, n_sim,
                                   lambda_pi, lambda_x, lambda_i)
            Z[i, j] = loss
    Zs.append(Z)

# --- Plotting Setup ---
fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

# Set labels and limits
ax.set_xlabel(r'$\phi_\pi$', fontsize=12)
ax.set_ylabel(r'$\phi_y$', fontsize=12)
ax.set_zlabel('Loss', fontsize=12)
ax.set_zlim(0.0, max([Z.max() for Z in Zs]) * 1.1)

# Initial plot
surf = ax.plot_surface(X, Y, Zs[0], cmap='viridis', alpha=0.8)
ax.set_title(f'Loss Surface at Time Horizon T = {time_horizons[0]}')

# --- Animation Function ---
def update_plot(frame):
    ax.clear()  # Clear the entire axes
    
    # Redraw the surface
    surf = ax.plot_surface(X, Y, Zs[frame], cmap='viridis', alpha=0.8)
    
    # Reset labels and limits
    ax.set_xlabel(r'$\phi_\pi$', fontsize=12)
    ax.set_ylabel(r'$\phi_y$', fontsize=12)
    ax.set_zlabel('Loss', fontsize=12)
    ax.set_zlim(0.0, max([Z.max() for Z in Zs]) * 1.1)
    ax.set_title(f'Loss Surface at Time Horizon T = {time_horizons[frame]}')
    
    return surf,

# --- Create Animation ---
anim = animation.FuncAnimation(fig, update_plot, frames=len(time_horizons), 
                             interval=1500, repeat=True, blit=False)

# --- Display in Colab ---
plt.tight_layout()
HTML(anim.to_jshtml())
