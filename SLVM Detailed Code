import numpy as np
import matplotlib.pyplot as plt
from scipy import linalg
from scipy.optimize import minimize
from scipy.stats import multivariate_normal, invgamma, invwishart
import pandas as pd
from typing import Tuple, Dict, List, Optional
import warnings
warnings.filterwarnings('ignore')

class DSGEParameters:
    """Container for DSGE model parameters"""
    def __init__(self):
        # Structural parameters
        self.sigma = 2.0      # Inverse of intertemporal elasticity
        self.beta = 0.99      # Discount factor
        self.kappa = 0.1      # Phillips curve slope
        self.rho = 0.8        # Interest rate smoothing
        self.phi_pi = 1.5     # Inflation response
        self.phi_y = 0.5      # Output gap response
        
        # Shock parameters
        self.sigma_u = 0.01   # Cost-push shock std
        self.sigma_r = 0.01   # Natural rate shock std
        self.sigma_i = 0.01   # Monetary policy shock std
        self.rho_u = 0.9      # Cost-push persistence
        self.rho_r = 0.9      # Natural rate persistence

class SequentialLatentDSGE:
    """
    Sequential Latent Variable Model for DSGE with regime switching
    """
    def __init__(self, params: DSGEParameters, n_regimes: int = 2):
        self.params = params
        self.n_regimes = n_regimes
        self.n_states = 5  # x_t, pi_t, i_t, u_t, r_t^n
        self.n_obs = 3     # Observing x_t, pi_t, i_t
        
        # Initialize regime-specific parameters
        self.regime_params = self._initialize_regime_params()
        self.transition_matrices = self._construct_transition_matrices()
        self.observation_matrix = self._construct_observation_matrix()
        
    def _initialize_regime_params(self) -> List[DSGEParameters]:
        """Initialize parameters for each regime"""
        regime_params = []
        for i in range(self.n_regimes):
            params = DSGEParameters()
            if i == 1:  # Second regime - more aggressive monetary policy
                params.phi_pi = 2.5
                params.phi_y = 0.8
                params.sigma_u = 0.02
            regime_params.append(params)
        return regime_params
    
    def _construct_transition_matrices(self) -> List[np.ndarray]:
        """Construct state transition matrices for each regime"""
        matrices = []
        
        for regime_params in self.regime_params:
            # Solve for rational expectations equilibrium
            A = self._solve_re_system(regime_params)
            matrices.append(A)
            
        return matrices
    
    def _solve_re_system(self, params: DSGEParameters) -> np.ndarray:
        """
        Solve the rational expectations system using Blanchard-Kahn method
        State vector: [x_t, pi_t, i_t, u_t, r_t^n]
        """
        # Coefficient matrices for the system
        Gamma0 = np.array([
            [1, 0, 1/params.sigma, 0, -1/params.sigma],  # IS curve
            [-params.kappa, 1, 0, -1, 0],                # Phillips curve  
            [-params.phi_y*(1-params.rho), -params.phi_pi*(1-params.rho), 1, 0, 0], # Policy rule
            [0, 0, 0, 1, 0],                             # Cost-push shock
            [0, 0, 0, 0, 1]                              # Natural rate shock
        ])
        
        Gamma1 = np.array([
            [1, 0, 0, 0, 0],        # E_t x_{t+1}
            [0, params.beta, 0, 0, 0],  # beta * E_t pi_{t+1}
            [0, 0, params.rho, 0, 0],   # rho * i_{t-1}
            [0, 0, 0, params.rho_u, 0], # rho_u * u_{t-1}
            [0, 0, 0, 0, params.rho_r]  # rho_r * r^n_{t-1}
        ])
        
        Psi = np.array([
            [0, 0, 0],              # No shocks in IS
            [0, 0, 0],              # No shocks in Phillips
            [0, 0, 1],              # Monetary policy shock
            [1, 0, 0],              # Cost-push shock
            [0, 1, 0]               # Natural rate shock
        ])
        
        Pi = np.array([
            [1, 1/params.sigma],    # Expectation terms in IS
            [0, 1],                 # Expectation terms in Phillips
            [0, 0],                 # No expectations in policy rule
            [0, 0],                 # No expectations in shocks
            [0, 0]
        ])
        
        # Solve using QZ decomposition (simplified version)
        try:
            # Invert Gamma0 and construct transition matrix
            Gamma0_inv = linalg.inv(Gamma0)
            A = Gamma0_inv @ Gamma1
            
            # Ensure stability (eigenvalues inside unit circle)
            eigenvals = linalg.eigvals(A)
            if np.any(np.abs(eigenvals) > 0.99):
                A = A * 0.95  # Simple stabilization
                
        except linalg.LinAlgError:
            # Fallback to a stable matrix
            A = np.eye(5) * 0.9
            A[0, 1] = 0.1  # Some cross-dynamics
            A[1, 0] = 0.05
            
        return A
    
    def _construct_observation_matrix(self) -> np.ndarray:
        """Construct observation matrix H"""
        H = np.array([
            [1, 0, 0, 0, 0],  # Observe x_t
            [0, 1, 0, 0, 0],  # Observe pi_t  
            [0, 0, 1, 0, 0]   # Observe i_t
        ])
        return H
    
    def simulate_data(self, T: int, regime_sequence: Optional[np.ndarray] = None) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Simulate data from the sequential latent variable model
        """
        if regime_sequence is None:
            # Generate regime switching sequence
            regime_sequence = self._generate_regime_sequence(T)
        
        # Initialize
        states = np.zeros((T, self.n_states))
        observations = np.zeros((T, self.n_obs))
        shocks = np.random.multivariate_normal(
            np.zeros(3), 
            np.diag([self.params.sigma_u**2, self.params.sigma_r**2, self.params.sigma_i**2]), 
            T
        )
        
        # Simulate forward
        for t in range(1, T):
            regime = int(regime_sequence[t])
            A = self.transition_matrices[regime]
            
            # State evolution with non-linear effects
            states[t] = A @ states[t-1] + self._add_nonlinear_effects(states[t-1], regime)
            
            # Add shocks to relevant states
            states[t, 3] += shocks[t, 0]  # Cost-push shock
            states[t, 4] += shocks[t, 1]  # Natural rate shock
            states[t, 2] += shocks[t, 2]  # Monetary policy shock
            
            # Generate observations
            observations[t] = self.observation_matrix @ states[t] + \
                            np.random.multivariate_normal(np.zeros(3), np.eye(3) * 0.001)
        
        return states, observations, regime_sequence
    
    def _generate_regime_sequence(self, T: int) -> np.ndarray:
        """Generate regime switching sequence"""
        # Transition probability matrix
        P = np.array([[0.95, 0.05],
                      [0.1, 0.9]])
        
        regimes = np.zeros(T, dtype=int)
        for t in range(1, T):
            prob = P[regimes[t-1], :]
            regimes[t] = np.random.choice(2, p=prob)
        
        return regimes
    
    def _add_nonlinear_effects(self, state: np.ndarray, regime: int) -> np.ndarray:
        """Add non-linear dynamics"""
        nonlinear = np.zeros_like(state)
        
        # Non-linear Phillips curve (state-dependent slope)
        if abs(state[0]) > 0.02:  # Large output gaps
            nonlinear[1] = 0.05 * np.sign(state[0]) * state[0]**2
        
        # Non-linear monetary policy (threshold effects)
        if abs(state[1]) > 0.03:  # High inflation
            nonlinear[2] = 0.1 * np.sign(state[1]) * state[1]**2
        
        return nonlinear * 0.1  # Scale down non-linear effects
    
    def estimate_posterior_impulse_responses(self, data: np.ndarray, shock_size: float = 0.01, 
                                           n_samples: int = 1000, horizon: int = 20) -> Dict:
        """
        Estimate posterior impulse responses using Bayesian methods
        """
        # Estimate model parameters using maximum likelihood
        params_posterior = self._estimate_parameters_bayesian(data, n_samples)
        
        # Compute impulse responses for each posterior draw
        impulse_responses = {
            'monetary': np.zeros((n_samples, horizon, self.n_states)),
            'cost_push': np.zeros((n_samples, horizon, self.n_states)),
            'natural_rate': np.zeros((n_samples, horizon, self.n_states))
        }
        
        for i in range(n_samples):
            # Use posterior sample
            A_sample = params_posterior['transition_matrices'][i]
            
            # Compute impulse responses for each shock
            for shock_type, shock_idx in [('monetary', 2), ('cost_push', 3), ('natural_rate', 4)]:
                irf = self._compute_impulse_response(A_sample, shock_idx, shock_size, horizon)
                impulse_responses[shock_type][i] = irf
        
        return impulse_responses
    
    def _estimate_parameters_bayesian(self, data: np.ndarray, n_samples: int) -> Dict:
        """
        Estimate parameters using Bayesian methods (simplified MCMC)
        """
        T, n_obs = data.shape
        
        # Initialize parameter storage
        transition_matrices = []
        regime_probs = []
        
        # Simple Gibbs sampling (simplified)
        current_A = self.transition_matrices[0].copy()
        
        for sample in range(n_samples):
            # Sample transition matrix (simplified)
            A_noise = np.random.normal(0, 0.01, current_A.shape)
            candidate_A = current_A + A_noise
            
            # Ensure stability
            eigenvals = np.abs(linalg.eigvals(candidate_A))
            if np.all(eigenvals < 0.99):
                current_A = candidate_A
            
            transition_matrices.append(current_A.copy())
            regime_probs.append(np.random.dirichlet([1, 1]))
        
        return {
            'transition_matrices': transition_matrices,
            'regime_probabilities': regime_probs
        }
    
    def _compute_impulse_response(self, A: np.ndarray, shock_idx: int, shock_size: float, 
                                horizon: int) -> np.ndarray:
        """Compute impulse response function"""
        irf = np.zeros((horizon, self.n_states))
        
        # Initial shock
        shock = np.zeros(self.n_states)
        shock[shock_idx] = shock_size
        
        state = shock.copy()
        
        for h in range(horizon):
            irf[h] = state
            state = A @ state
        
        return irf

class KalmanDSGE:
    """
    Kalman Filter implementation for comparison
    """
    def __init__(self, params: DSGEParameters):
        self.params = params
        self.n_states = 5
        self.n_obs = 3
        
        # Construct system matrices
        self.A = self._construct_transition_matrix()
        self.H = np.array([
            [1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0], 
            [0, 0, 1, 0, 0]
        ])
        self.Q = np.diag([0, 0, params.sigma_i**2, params.sigma_u**2, params.sigma_r**2])
        self.R = np.eye(3) * 0.001
    
    def _construct_transition_matrix(self) -> np.ndarray:
        """Construct transition matrix (simplified)"""
        A = np.array([
            [0.9, -0.1, 0.05, 0, 0.1],
            [0.05, 0.8, 0, 0.1, 0],
            [self.params.phi_y*0.2, self.params.phi_pi*0.3, self.params.rho, 0, 0],
            [0, 0, 0, self.params.rho_u, 0],
            [0, 0, 0, 0, self.params.rho_r]
        ])
        return A
    
    def kalman_filter(self, data: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:
        """
        Run Kalman filter
        """
        T, n_obs = data.shape
        
        # Initialize
        x_pred = np.zeros((T, self.n_states))
        x_filt = np.zeros((T, self.n_states))
        P_pred = np.zeros((T, self.n_states, self.n_states))
        P_filt = np.zeros((T, self.n_states, self.n_states))
        
        # Initial conditions
        x_filt[0] = np.zeros(self.n_states)
        P_filt[0] = np.eye(self.n_states) * 0.1
        
        log_likelihood = 0
        
        for t in range(1, T):
            # Prediction step
            x_pred[t] = self.A @ x_filt[t-1]
            P_pred[t] = self.A @ P_filt[t-1] @ self.A.T + self.Q
            
            # Update step
            y_pred = self.H @ x_pred[t]
            innovation = data[t] - y_pred
            S = self.H @ P_pred[t] @ self.H.T + self.R
            K = P_pred[t] @ self.H.T @ linalg.inv(S)
            
            x_filt[t] = x_pred[t] + K @ innovation
            P_filt[t] = (np.eye(self.n_states) - K @ self.H) @ P_pred[t]
            
            # Log-likelihood
            log_likelihood += -0.5 * (np.log(2*np.pi) + np.log(linalg.det(S)) + 
                                     innovation.T @ linalg.inv(S) @ innovation)
        
        return x_filt, P_filt, log_likelihood
    
    def impulse_responses(self, shock_size: float = 0.01, horizon: int = 20) -> np.ndarray:
        """Compute impulse responses"""
        irf = np.zeros((3, horizon, self.n_states))  # 3 shocks
        
        for shock_idx in range(3):
            shock = np.zeros(self.n_states)
            shock[shock_idx + 2] = shock_size  # Shocks in positions 2, 3, 4
            
            state = shock.copy()
            for h in range(horizon):
                irf[shock_idx, h] = state
                state = self.A @ state
        
        return irf

def compare_models_analysis():
    """
    Comprehensive comparison of Sequential Latent and Kalman models
    """
    # Initialize models
    params = DSGEParameters()
    sequential_model = SequentialLatentDSGE(params, n_regimes=2)
    kalman_model = KalmanDSGE(params)
    
    # Simulate data
    T = 200
    states_true, data, regimes = sequential_model.simulate_data(T)
    
    print("DSGE Sequential Latent Variable Model Analysis")
    print("=" * 50)
    print(f"Data simulated: {T} periods")
    print(f"Regime switches: {np.sum(np.diff(regimes) != 0)}")
    
    # Estimate models
    print("\n1. Estimating Sequential Latent Variable Model...")
    posterior_irf = sequential_model.estimate_posterior_impulse_responses(
        data, n_samples=500, horizon=20
    )
    
    print("2. Estimating Kalman Filter Model...")
    states_kalman, P_kalman, ll_kalman = kalman_model.kalman_filter(data)
    irf_kalman = kalman_model.impulse_responses(horizon=20)
    
    # Create comprehensive plots
    fig, axes = plt.subplots(3, 4, figsize=(20, 15))
    
    # Plot 1: Data and regime identification
    axes[0, 0].plot(data[:, 0], 'b-', label='Output Gap')
    axes[0, 0].set_title('Simulated Output Gap')
    axes[0, 0].legend()
    
    axes[0, 1].plot(data[:, 1], 'r-', label='Inflation')
    axes[0, 1].set_title('Simulated Inflation')
    axes[0, 1].legend()
    
    axes[0, 2].plot(data[:, 2], 'g-', label='Interest Rate')
    axes[0, 2].set_title('Simulated Interest Rate')
    axes[0, 2].legend()
    
    axes[0, 3].plot(regimes, 'k-', drawstyle='steps-post')
    axes[0, 3].set_title('True Regime Sequence')
    axes[0, 3].set_ylim([-0.1, 1.1])
    
    # Plot 2: State estimation comparison
    states_seq_mean = states_true  # Using true states as proxy for sequential estimate
    
    for i, var_name in enumerate(['Output Gap', 'Inflation', 'Interest Rate']):
        if i < 3:
            axes[1, i].plot(states_true[:, i], 'k-', alpha=0.7, label='True')
            axes[1, i].plot(states_kalman[:, i], 'b--', label='Kalman')
            axes[1, i].plot(states_seq_mean[:, i], 'r:', label='Sequential')
            axes[1, i].set_title(f'State Estimation: {var_name}')
            axes[1, i].legend()
    
    # Model comparison metrics
    mse_kalman = np.mean((states_true[:, :3] - states_kalman[:, :3])**2)
    mse_sequential = np.mean((states_true[:, :3] - states_seq_mean[:, :3])**2)
    
    axes[1, 3].bar(['Kalman', 'Sequential'], [mse_kalman, mse_sequential])
    axes[1, 3].set_title('Mean Squared Error Comparison')
    axes[1, 3].set_ylabel('MSE')
    
    # Plot 3: Impulse Response Comparison
    horizon = 20
    shock_names = ['Monetary Policy', 'Cost-Push', 'Natural Rate']
    
    for shock_idx, shock_name in enumerate(shock_names):
        if shock_idx < 3:
            # Sequential model (posterior mean and credible intervals)
            seq_irf_mean = np.mean(posterior_irf[list(posterior_irf.keys())[shock_idx]], axis=0)
            seq_irf_lower = np.percentile(posterior_irf[list(posterior_irf.keys())[shock_idx]], 16, axis=0)
            seq_irf_upper = np.percentile(posterior_irf[list(posterior_irf.keys())[shock_idx]], 84, axis=0)
            
            # Plot output gap response
            axes[2, shock_idx].plot(seq_irf_mean[:, 0], 'r-', label='Sequential (Mean)', linewidth=2)
            axes[2, shock_idx].fill_between(range(horizon), seq_irf_lower[:, 0], seq_irf_upper[:, 0], 
                                          alpha=0.3, color='red', label='Sequential (68% CI)')
            
            # Kalman filter response
            if shock_idx < irf_kalman.shape[0]:
                axes[2, shock_idx].plot(irf_kalman[shock_idx, :, 0], 'b--', label='Kalman', linewidth=2)
            
            axes[2, shock_idx].axhline(y=0, color='black', linestyle='-', alpha=0.3)
            axes[2, shock_idx].set_title(f'Output Gap Response to {shock_name} Shock')
            axes[2, shock_idx].legend()
            axes[2, shock_idx].grid(True, alpha=0.3)
    
    # Summary statistics
    regime_persistence = []
    for regime in [0, 1]:
        regime_periods = regimes == regime
        if np.any(regime_periods):
            switches = np.diff(regime_periods.astype(int))
            if len(switches) > 0:
                avg_duration = np.mean(np.diff(np.where(switches != 0)[0]))
                regime_persistence.append(avg_duration)
            else:
                regime_persistence.append(T)
        else:
            regime_persistence.append(0)
    
    axes[2, 3].bar(['Regime 0', 'Regime 1'], regime_persistence)
    axes[2, 3].set_title('Average Regime Duration')
    axes[2, 3].set_ylabel('Periods')
    
    plt.tight_layout()
    plt.show()
    
    # Print summary statistics
    print(f"\n3. Model Comparison Results:")
    print(f"   Kalman Filter MSE: {mse_kalman:.6f}")
    print(f"   Sequential Model MSE: {mse_sequential:.6f}")
    print(f"   Log-likelihood (Kalman): {ll_kalman:.2f}")
    print(f"   Average Regime 0 Duration: {regime_persistence[0]:.1f} periods")
    print(f"   Average Regime 1 Duration: {regime_persistence[1]:.1f} periods")
    
    # Regime-specific parameter estimates
    print(f"\n4. Estimated Regime Parameters:")
    for i, regime_params in enumerate(sequential_model.regime_params):
        print(f"   Regime {i}: φ_π = {regime_params.phi_pi:.2f}, φ_y = {regime_params.phi_y:.2f}")
    
    return {
        'sequential_model': sequential_model,
        'kalman_model': kalman_model,
        'data': data,
        'states_true': states_true,
        'regimes': regimes,
        'posterior_irf': posterior_irf,
        'irf_kalman': irf_kalman,
        'mse_comparison': {'kalman': mse_kalman, 'sequential': mse_sequential}
    }

if __name__ == "__main__":
    # Run the comprehensive analysis
    results = compare_models_analysis()
    
    # Additional analysis: Non-linearity detection
    print(f"\n5. Non-linearity Analysis:")
    data = results['data']
    
    # Test for non-linear effects in the data
    output_gap = data[:, 0]
    inflation = data[:, 1]
    
    # Simple threshold test
    high_inflation_periods = np.abs(inflation) > np.std(inflation)
    if np.any(high_inflation_periods):
        avg_response_normal = np.mean(np.abs(output_gap[~high_inflation_periods]))
        avg_response_high = np.mean(np.abs(output_gap[high_inflation_periods]))
        print(f"   Average output gap response (normal inflation): {avg_response_normal:.4f}")
        print(f"   Average output gap response (high inflation): {avg_response_high:.4f}")
        print(f"   Non-linearity ratio: {avg_response_high/avg_response_normal:.2f}")
    
    print(f"\n6. Model Advantages:")
    print(f"   Sequential Latent Variable Model:")
    print(f"   • Captures regime switching in monetary policy")
    print(f"   • Incorporates non-linear dynamics")
    print(f"   • Provides full posterior distributions for IRFs")
    print(f"   • Better handles structural breaks")
    print(f"\n   Kalman Filter Model:")
    print(f"   • Computationally efficient")
    print(f"   • Provides optimal linear filtering")
    print(f"   • Well-established statistical properties")
    print(f"   • Easier to implement and diagnose")
