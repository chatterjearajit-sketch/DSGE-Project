# --- Extended DSGE IRF Simulation with Additional Shocks ---
import numpy as np
import matplotlib.pyplot as plt

# === Model Parameters ===
beta = 0.99
sigma = 1.0
kappa = 0.1
phi_pi = 1.5
phi_y = 0.5
rho = 0.8

# === State-Space Variables ===
# [x_t, pi_t, i_t, i_{t-1}]
n_vars = 4
T = 40  # Time horizon

# === Transition Matrix ===
# A encodes y_{t+1} = A y_t
A = np.array([
    [0.5, -0.5, -0.5, 0.0],     # x_t
    [0.05, 0.98, -0.05, 0.0],   # pi_t
    [0.2, 1.2, 0.0, 0.8],       # i_t
    [0.0, 0.0, 1.0, 0.0]        # i_{t-1}
])

# === Define Shock Vectors ===
# B_shock = [impact on x_t, pi_t, i_t, i_{t-1}]

shock_vectors = {
    'Technology Shock':         np.array([1.0, 0.0, 0.0, 0.0]),
    'Monetary Policy Shock':    np.array([0.0, 0.0, 1.0, 0.0]),
    'Markup Shock':             np.array([0.0, 1.0, 0.0, 0.0]),
    'Preference Shock':         np.array([-1.0, 0.0, 0.0, 0.0]),
    'Wage Shock':               np.array([0.0, 0.5, 0.0, 0.0])
}

# === Simulate IRFs for Each Shock ===
IRFs = {}
for shock_name, shock_vec in shock_vectors.items():
    irf = np.zeros((n_vars, T))
    irf[:, 0] = shock_vec
    for t in range(1, T):
        irf[:, t] = A @ irf[:, t - 1]
    IRFs[shock_name] = irf

# === Plot IRFs ===
variables = ['Output Gap (x)', 'Inflation (π)', 'Interest Rate (i)', 'Lagged Rate (iₜ₋₁)']
n_shocks = len(shock_vectors)
fig, axes = plt.subplots(n_vars, n_shocks, figsize=(4 * n_shocks, 10), sharex=True)
time = np.arange(T)

for col, (shock_name, irf) in enumerate(IRFs.items()):
    for row in range(n_vars):
        ax = axes[row, col] if n_shocks > 1 else axes[row]
        ax.plot(time, irf[row], label=variables[row], color='blue')
        ax.axhline(0, color='black', linestyle='--', linewidth=0.5)
        if row == 0:
            ax.set_title(shock_name, fontsize=12)
        if col == 0:
            ax.set_ylabel(variables[row])
        ax.grid(True)

plt.tight_layout()
plt.show()
